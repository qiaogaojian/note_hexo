---
title: Unity3D高级编程 主程手记
date: 2022-11-12 00:42:56
categories: []
tags: ['技能', 'book', 'srcard', 'Unity3d']
---
  
  
## 第1章 软件架构

  
  
### 1.1 架构的意义  

在软件系统中，架构的重要性不言而喻，项目从研发到上线运营，我们要在不同的方案中选择合适的架构，例如，前端渲染引擎是自己研发，还是使用商业引擎？商业引擎是使用Unity3D，还是Unreal或其他？具体到怎么用，则要考虑是使用UGUI，还是使用NGUI？UI里的事件系统如何进行统一处理？AI行为算法是选择行为树，还是状态机，抑或是选择事件型决策树？数据如何获取和存储？场景如何拆分？是否需要将资源分离出去？是使用长连接还是短连接？是选择TCP还是UDP？服务器端是用C++，还是用Java或Python？是全部使用关系型数据库，还是加入Cache机制？网络协议是用Protocol Buff，还是用JSON或XML，抑或是使用完全自定义格式等。  
  
这些项目中的每个子系统都要有自己的方向，把子系统的决策方向合起来再加入它们之间的关联调用就构成了一个完整的架构，即每个系统、模块、组件都是软件系统架构中的一部分。  
  
一个完整的架构图通常会伴随些许子系统的细节，或者说子模块的架构图。UML对象关系图就是一种架构图，它描述了数据类之间的关系，可把系统中的对象用文字和连接图的方式描述清楚。部署图也是其中一种架构图，它把需要多少种服务器、它们分别起到什么作用，以及它们相互之间的关系描述清楚了，而时序图则把系统程序调用的次序与流程描述清楚了。这些不同角度的架构图合起来就构成了一个完整的项目架构图。如果把子系统架构细节略去，在不关心细节的情况下，描述各系统的合作方式，展现给人们的是整体的解决方案，从宏观的角度看整个项目的布局，会让人一目了然。  
  
可以把软件架构理解为软件程序的架子，与现实中的书架有异曲同工之妙，这个架子上有很多大大小小的格子，每个格子里都可以放置固定种类的程序。架子有大有小，大的需要花费点时间去定制，小的则轻便快捷。  
  
架子的大小是由设计师决定的，设计师根据客户的需求设计，假如放置的空间大，且需要承载的东西多，那么就往容量大的方向设计，让它能容纳更多的东西，能放置各种不同类型的程序，反之则做得简约些，这样更容易理解，又轻又快。  
  
架子完成后要拿出去用，如果一出现异常情况就倒了或散架了，就不算是一个好的架子，架子的好坏可从以下几个方面进行评估。  
  
1. **承载力**  
  
书架上能放多少东西，能放多重的东西，是使用者（这里使用者可以为客户、玩家或程序员）比较关注的问题。  
  
从软件架构的程序意义来说，一个架构能承载多少个逻辑系统，当代码行数扩展到100万行时是否依然能够有序且规范地运行，以及程序员彼此工作的模块耦合度是否依然能保持原来的设计要求，能够承载多少个程序员共同开发，共同开发的效率又如何，这是对软件架构承载力的评定指标。  
  
从架构的目标上来看，对于服务器来说，当前架构能承受多少人同时访问，能承载的日均访问量是多少，这就是它承载力的体现。而对于客户端来说，能显示多少UI元素，可渲染多少模型（包括同屏渲染和非同屏渲染），则是它的承载力的体现。  
  
2. **可扩展性**  
  
如果书架上只能放书，这个书架的用途就太单一了，花瓶不能放、箱子不能放、鞋子不能放、袋子不能放、衣服不能放，客户八成不买单。  
  
3. **易用性**  
  
易用性是架构师比较容易忽视的一个点。如果架构师设计了完整的架构，但具体执行时被程序员认为不好用，这时架构师还是执着地推动它的使用，那么团队间就会加深矛盾，这样开发效率就会下降。  
  
4. **可伸缩性**  
  
还是用书架比喻，假设现在没有这么多书和东西要放，房子也不够大，那么书架如果可以折叠缩小到我需要的大小则会更受用户欢迎，这就是可伸缩性的体现。  
  
若软件架构能像我们制造的书架一样可随时放大或随时折叠缩小，那就太好了。当需要的承载量没有这么大时，可以不使用不需要的功能，化繁为简，只启用需要的部分功能，这样就可以随时简化开发流程。  
  
5. **容错性以及错误的感知力**  
  
书架也会有磕磕碰碰的时候，同样也会出现因某处做工不精导致使用时歪歪斜斜的情况，如果我们保证不了完全没有问题，至少需要保证它不会因为一点小小的毛病而彻底散架。  
  
从服务器端角度，容错性包括数据库容错性、应用服务器容错性、缓存服务器容错性，以及中心服务器容错性，每个环节出现问题都会通知相关中心服务器改变策略，或者监控服务器检测得知该服务器出现故障，自动更换成备用服务器或者更换链路。  
  
从客户端角度，容错性包括当程序发生错误时，是否同样能够继续保持运行而不崩溃；当这个页面程序出错时，是否依然能够运行其他程序而不闪退或崩溃。同时所有出现的程序错误，都能及时地记录下来并发送到后台，存储为错误日志，便于开发人员及时得到详细的错误信息，能够根据错误信息快速找出问题所在。  
  
    
  
### 1.2 软件架构的思维方式  

《优秀架构师必须掌握的架构思维》的文章就很好地对抽象能力进行了分析，以下三种抽象能力源自这篇文章。

**第一种：分层思维**  
  
分层是我们应对和管理复杂性的基本思维武器。  
  
面对一个复杂的系统，我们一开始总是无从下手，就好比一下子在我们面前摆了很多的问题，杂乱无章。这很大程度上会导致我们慌张、焦急、惶恐。分层思维，能很好地帮助我们抽象一个复杂系统的架构层次，从而清晰地描述有多少层面的事务需要我们解决，以及解决层级的先后次序。  
  
**第二种：分治思维**  
  
分而治之也是应对和管理复杂性的一般性方法  
  
对于一个无法一次解决的大问题，我们先把大问题分解成若干个子问题，如果子问题还无法解决，则继续分解成子子问题，直到可以直接解决为止，这就是分解（divide）的过程；然后将子子问题的解组合成子问题的解，再将子问题的解组合成原问题的解，这就是组合（combine）的过程。  
  
**第三种：演化思维**  
  
经常有人讨论：架构是设计出来的还是演化出来的？基于多年的经验，我认为架构既是设计出来的，同时也是演化出来的。对于互联网系统，基本上可以说是三分设计，七分演化，既在设计中演化，又在演化中设计，是一个不断迭代的过程。  
    
  
### 1.3 如何构建Unity3D项目  

1. **前端与后端架构之间的共性**  
  
前后端架构的目标都是高性能、高可用、可扩展、安全、可容错。对于前端来说，除了这些目标特性外，还需要加入更多的用户体验，包括视觉效果和操作灵敏度。  
  
作为前端工程师，用户体验是比较重要的，这种体验涉及很多方面，包括性能、视觉效果，以及操作上的人性化等。例如，如何让游戏加载速度更流畅、如何制作更绚丽的特效、如何减少电量的消耗、如何最快地响应用户操作等。  
  
2. **培养架构设计思维**  
  
良好的架构设计思维的培养，离不开工作中大量高质量项目的实战锻炼，以及平时的学习、思考和总结。  
  
基本的架构设计思维在大学计算机课程（比如数据结构和算法）中可以找到，大学里以学习理论知识为主。回头看，基本的架构设计思维在那时就已经埋下种子，后面的工程实践会进一步消化和应用所学的理论知识，随着经验的积累，我们能够解决的问题的复杂性和规模逐渐变大，但所用的方法依然是抽象、分层、分治和演化。  
  
3. **试着构建Unity3D项目**  
  
我们可以使用以上方法来试着构建Unity3D项目。下面采用分层的思维方式先确定架构的层级，如图1-8所示。  
  
图1-8　Unity3D分层设计  
  
把整个项目分成五大层级，即网络层、数据管理层、资源管理层、核心逻辑框架层、UI框架层。  
  
  
第2章 C#技术要点  
2.1　Unity3D中C#的底层原理  
  
Unity底层在运行C#程序时有两种机制，一种是Mono，另一种是IL2CPP。  
  
这里要引出一个很重要的概念“IL”。IL的全称是Intermediate Language，但很多时候我们看到的是CIL（Common Intermediate Language，特指在.NET平台下的IL标准），其实大部分文章中提到的IL和CIL表示的是同一个东西，即中间语言。  
  
IL是一种低阶（lowest-level）的人类可读的编程语言。我们可以将通用语言翻译成IL，然后汇编成字节码，最后运行在虚拟机上；也可以把IL看作一个面向对象的汇编语言，只是它必须运行在虚拟机上，而且是完全基于堆栈的语言。也就是说，C#、VB、J#这种遵循CLI规范的高级语言，会被各自的编译器编译成中间语言IL（CIL），当需要运行它们时就会被实时地加载到运行时库中，由虚拟机动态地编译成汇编代码（JIT）并执行。  
  
  
2.1 Unity3D中C#的底层原理  
其实IL有三种转译模式。  
  
·Just-in-time（JIT）编译：在程序运行过程中将CIL转译为机器码。  
  
·Ahead-of-Time（AOT）编译：将IL转译成机器码并存储在文件中，此文件并不能完全独立运行。通常此种模式可产生出绝大部分JIT模式所产生的机器码，只是有部分例外，例如trampolines或是控管监督相关的代码仍旧需要JIT来运行。  
  
·完全静态编译：这个模式只支持少数平台，它基于AOT编译模式更进一步产生所有的机器码。完全静态编译模式可以让程序在运行期完全不需要用到JIT，这个做法适用于iOS操作系统、PlayStation 3以及XBox 360等不允许使用JIT的操作系统。  
  
Unity在打包iOS操作系统的时候就使用了第三种方式，而在Android和Windows上则使用JIT实时编译来运行代码。  
  
